Traceback (most recent call last):
  File "/home/dkeathley/anaconda3/lib/python3.8/site-packages/jupyter_cache/executors/utils.py", line 58, in single_nb_execution
    executenb(
  File "/home/dkeathley/anaconda3/lib/python3.8/site-packages/nbclient/client.py", line 1265, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
  File "/home/dkeathley/anaconda3/lib/python3.8/site-packages/jupyter_core/utils/__init__.py", line 160, in wrapped
    return loop.run_until_complete(inner)
  File "/home/dkeathley/anaconda3/lib/python3.8/asyncio/base_events.py", line 616, in run_until_complete
    return future.result()
  File "/home/dkeathley/anaconda3/lib/python3.8/site-packages/nbclient/client.py", line 703, in async_execute
    await self.async_execute_cell(
  File "/home/dkeathley/anaconda3/lib/python3.8/site-packages/nbclient/client.py", line 1021, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "/home/dkeathley/anaconda3/lib/python3.8/site-packages/nbclient/client.py", line 915, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
#Setup the workspace
%reset
import numpy as np
import matplotlib.pyplot as plt
import scipy.io as sio
import scipy.interpolate as interpolate
import scipy.optimize as sco

import sys
sys.path.append('../includes')
import physical_constants_SI as pcSI


def n_kk(y, k, y_0, n_0, dw_prime):
    """
    Evaluates the refractive index from the absorption values k as a function of 
    frequency, w.  The index is evaluated over all values w thus providing full
    complex index information (n + ik) for the material.  Only one real index of
    refraction value, n_0 evaluated at frequency w_0, is needed for the offset. 

    The absorption terms k can be derived from extinction data.  This is very 
    useful as often times the extinction is measured from many specimens in the
    laboratory, meaning that this offers a way to evaluate refractive index from
    a variety of complex substances.  

    Inputs     Units     Description
    ------     -----     -----------
     y         nm        Wavelength vector associated with vector of k values.  
                         Must be monotonic increasing.
     k                   Vector of k-values.  Can be derived from extinction data.
     y_0       nm        The central wavelength where a known index n_0 is provided. 
     n_0                 The known index at y_0.
     dw_prime  1/nm      The spacing for the numerical integral over w_prime in the 
                         Kramers-Kronig calculation.  This should be small-enough 
                         to provide convergence of the refractive index calculation.
                         It is with respect to normalized frequency (simply 1/y)


    Outputs
    -----------
     n         Vector containing the real part of the refractive index
    """

    #Normalized frequency (simply 1/wavelength)
    w_norm = 1/y
    w_norm_0 = 1/y_0

    #Interpolation function:
    f_k = interpolate.interp1d(np.flip(w_norm),
                            np.flip(k), 
                            kind='cubic')

    n_prime = np.zeros(w_norm.shape)
    
    cc = 0
    for w_norm_eval in w_norm:

        #You are going to have 3 ranges:
        w_norm_p1 = np.min([w_norm_0, w_norm_eval])
        w_norm_p2 = np.max([w_norm_0, w_norm_eval])

        sum1 = 0
        sum2 = 0
        sum3 = 0

        #This will be the first range:
        N_1 = int(np.ceil((w_norm_p1 - dw_prime - w_norm[-1])/dw_prime))
        if (N_1 >= 0):
            w_norm_prime_1 = np.linspace(w_norm[-1], w_norm_p1 - dw_prime, N_1)
            k_Hb_prime_1 = f_k(w_norm_prime_1)
            integrand_1 = w_norm_prime_1*k_Hb_prime_1*(w_norm_0**2 - w_norm_eval**2)/\
                (w_norm_eval**2 - w_norm_prime_1**2)/(w_norm_0**2 - w_norm_prime_1**2)

            sum1 = np.trapz(integrand_1, x=w_norm_prime_1)
        

        #This will be the second range:
        N_2 = int(np.ceil((w_norm_p2 - dw_prime - (w_norm_p1 + dw_prime))/dw_prime))
        if (N_2 >= 0):
            w_norm_prime_2 = np.linspace(w_norm_p1 + dw_prime, w_norm_p2 - dw_prime, N_2)
            k_Hb_prime_2 = f_k(w_norm_prime_2)
            integrand_2 = w_norm_prime_2*k_Hb_prime_2*(w_norm_0**2 - w_norm_eval**2)/\
                (w_norm_eval**2 - w_norm_prime_2**2)/(w_norm_0**2 - w_norm_prime_2**2)
                
            sum2 = np.trapz(integrand_2, x=w_norm_prime_2)

            #This will be the third range:
            N_3 = int(np.ceil((w_norm[0] - (w_norm_p2 + dw_prime))/dw_prime))
        if (N_3 >= 0):
            w_norm_prime_3 = np.linspace(w_norm_p2 + dw_prime, w_norm[0], N_3)
            k_Hb_prime_3 = f_k(w_norm_prime_3)
            integrand_3 = w_norm_prime_3*k_Hb_prime_3*(w_norm_0**2 - w_norm_eval**2)/\
                (w_norm_eval**2 - w_norm_prime_3**2)/(w_norm_0**2 - w_norm_prime_3**2)
            
            sum3 = np.trapz(integrand_3, w_norm_prime_3)
            
        n_prime[cc] = (-2/np.pi)*(sum1 + sum2 + sum3)
        cc = cc + 1

    n = n_0 + n_prime

    return n

def eps_drude_lorentz(p, y):

    eps = p[0]

    p_sets = int((p.size - 1)/3)

    for cc in range(0, p_sets):

        alpha = p[3*cc + 1]
        beta = p[3*cc + 2]
        sigma = p[3*cc + 3]
        
        eps = eps + sigma*alpha**2*y**2/(alpha**2*y**2 - 1 - 1j*y*beta)

    return eps

def residuals(p, y, eps_meas):

    eps_calc = eps_drude_lorentz(p, y)

    M = np.abs(eps_calc - eps_meas)

    return M
------------------

[0;31m---------------------------------------------------------------------------[0m
[0;31mImportError[0m                               Traceback (most recent call last)
[0;32m/tmp/ipykernel_4205/2641998927.py[0m in [0;36m<cell line: 4>[0;34m()[0m
[1;32m      2[0m [0mget_ipython[0m[0;34m([0m[0;34m)[0m[0;34m.[0m[0mrun_line_magic[0m[0;34m([0m[0;34m'reset'[0m[0;34m,[0m [0;34m''[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m
[1;32m      3[0m [0;32mimport[0m [0mnumpy[0m [0;32mas[0m [0mnp[0m[0;34m[0m[0;34m[0m[0m
[0;32m----> 4[0;31m [0;32mimport[0m [0mmatplotlib[0m[0;34m.[0m[0mpyplot[0m [0;32mas[0m [0mplt[0m[0;34m[0m[0;34m[0m[0m
[0m[1;32m      5[0m [0;32mimport[0m [0mscipy[0m[0;34m.[0m[0mio[0m [0;32mas[0m [0msio[0m[0;34m[0m[0;34m[0m[0m
[1;32m      6[0m [0;32mimport[0m [0mscipy[0m[0;34m.[0m[0minterpolate[0m [0;32mas[0m [0minterpolate[0m[0;34m[0m[0;34m[0m[0m

[0;32m~/anaconda3/lib/python3.8/site-packages/matplotlib/__init__.py[0m in [0;36m<module>[0;34m[0m
[1;32m    111[0m [0;31m# cbook must import matplotlib only within function[0m[0;34m[0m[0;34m[0m[0;34m[0m[0m
[1;32m    112[0m [0;31m# definitions, so it is safe to import from it here.[0m[0;34m[0m[0;34m[0m[0;34m[0m[0m
[0;32m--> 113[0;31m [0;32mfrom[0m [0;34m.[0m [0;32mimport[0m [0m_api[0m[0;34m,[0m [0m_version[0m[0;34m,[0m [0mcbook[0m[0;34m,[0m [0m_docstring[0m[0;34m,[0m [0mrcsetup[0m[0;34m[0m[0;34m[0m[0m
[0m[1;32m    114[0m [0;32mfrom[0m [0mmatplotlib[0m[0;34m.[0m[0mcbook[0m [0;32mimport[0m [0msanitize_sequence[0m[0;34m[0m[0;34m[0m[0m
[1;32m    115[0m [0;32mfrom[0m [0mmatplotlib[0m[0;34m.[0m[0m_api[0m [0;32mimport[0m [0mMatplotlibDeprecationWarning[0m[0;34m[0m[0;34m[0m[0m

[0;32m~/anaconda3/lib/python3.8/site-packages/matplotlib/rcsetup.py[0m in [0;36m<module>[0;34m[0m
[1;32m     25[0m [0;32mfrom[0m [0mmatplotlib[0m [0;32mimport[0m [0m_api[0m[0;34m,[0m [0mcbook[0m[0;34m[0m[0;34m[0m[0m
[1;32m     26[0m [0;32mfrom[0m [0mmatplotlib[0m[0;34m.[0m[0mcbook[0m [0;32mimport[0m [0mls_mapper[0m[0;34m[0m[0;34m[0m[0m
[0;32m---> 27[0;31m [0;32mfrom[0m [0mmatplotlib[0m[0;34m.[0m[0mcolors[0m [0;32mimport[0m [0mColormap[0m[0;34m,[0m [0mis_color_like[0m[0;34m[0m[0;34m[0m[0m
[0m[1;32m     28[0m [0;32mfrom[0m [0mmatplotlib[0m[0;34m.[0m[0m_fontconfig_pattern[0m [0;32mimport[0m [0mparse_fontconfig_pattern[0m[0;34m[0m[0;34m[0m[0m
[1;32m     29[0m [0;32mfrom[0m [0mmatplotlib[0m[0;34m.[0m[0m_enums[0m [0;32mimport[0m [0mJoinStyle[0m[0;34m,[0m [0mCapStyle[0m[0;34m[0m[0;34m[0m[0m

[0;32m~/anaconda3/lib/python3.8/site-packages/matplotlib/colors.py[0m in [0;36m<module>[0;34m[0m
[1;32m     54[0m [0;32mimport[0m [0mmatplotlib[0m [0;32mas[0m [0mmpl[0m[0;34m[0m[0;34m[0m[0m
[1;32m     55[0m [0;32mimport[0m [0mnumpy[0m [0;32mas[0m [0mnp[0m[0;34m[0m[0;34m[0m[0m
[0;32m---> 56[0;31m [0;32mfrom[0m [0mmatplotlib[0m [0;32mimport[0m [0m_api[0m[0;34m,[0m [0m_cm[0m[0;34m,[0m [0mcbook[0m[0;34m,[0m [0mscale[0m[0;34m[0m[0;34m[0m[0m
[0m[1;32m     57[0m [0;32mfrom[0m [0;34m.[0m[0m_color_data[0m [0;32mimport[0m [0mBASE_COLORS[0m[0;34m,[0m [0mTABLEAU_COLORS[0m[0;34m,[0m [0mCSS4_COLORS[0m[0;34m,[0m [0mXKCD_COLORS[0m[0;34m[0m[0;34m[0m[0m
[1;32m     58[0m [0;34m[0m[0m

[0;32m~/anaconda3/lib/python3.8/site-packages/matplotlib/scale.py[0m in [0;36m<module>[0;34m[0m
[1;32m     20[0m [0;32mimport[0m [0mmatplotlib[0m [0;32mas[0m [0mmpl[0m[0;34m[0m[0;34m[0m[0m
[1;32m     21[0m [0;32mfrom[0m [0mmatplotlib[0m [0;32mimport[0m [0m_api[0m[0;34m,[0m [0m_docstring[0m[0;34m[0m[0;34m[0m[0m
[0;32m---> 22[0;31m from matplotlib.ticker import (
[0m[1;32m     23[0m     [0mNullFormatter[0m[0;34m,[0m [0mScalarFormatter[0m[0;34m,[0m [0mLogFormatterSciNotation[0m[0;34m,[0m [0mLogitFormatter[0m[0;34m,[0m[0;34m[0m[0;34m[0m[0m
[1;32m     24[0m     [0mNullLocator[0m[0;34m,[0m [0mLogLocator[0m[0;34m,[0m [0mAutoLocator[0m[0;34m,[0m [0mAutoMinorLocator[0m[0;34m,[0m[0;34m[0m[0;34m[0m[0m

[0;32m~/anaconda3/lib/python3.8/site-packages/matplotlib/ticker.py[0m in [0;36m<module>[0;34m[0m
[1;32m    136[0m [0;32mimport[0m [0mmatplotlib[0m [0;32mas[0m [0mmpl[0m[0;34m[0m[0;34m[0m[0m
[1;32m    137[0m [0;32mfrom[0m [0mmatplotlib[0m [0;32mimport[0m [0m_api[0m[0;34m,[0m [0mcbook[0m[0;34m[0m[0;34m[0m[0m
[0;32m--> 138[0;31m [0;32mfrom[0m [0mmatplotlib[0m [0;32mimport[0m [0mtransforms[0m [0;32mas[0m [0mmtransforms[0m[0;34m[0m[0;34m[0m[0m
[0m[1;32m    139[0m [0;34m[0m[0m
[1;32m    140[0m [0m_log[0m [0;34m=[0m [0mlogging[0m[0;34m.[0m[0mgetLogger[0m[0;34m([0m[0m__name__[0m[0;34m)[0m[0;34m[0m[0;34m[0m[0m

[0;32m~/anaconda3/lib/python3.8/site-packages/matplotlib/transforms.py[0m in [0;36m<module>[0;34m[0m
[1;32m     47[0m [0;34m[0m[0m
[1;32m     48[0m [0;32mfrom[0m [0mmatplotlib[0m [0;32mimport[0m [0m_api[0m[0;34m[0m[0;34m[0m[0m
[0;32m---> 49[0;31m from matplotlib._path import (
[0m[1;32m     50[0m     affine_transform, count_bboxes_overlapping_bbox, update_path_extents)
[1;32m     51[0m [0;32mfrom[0m [0;34m.[0m[0mpath[0m [0;32mimport[0m [0mPath[0m[0;34m[0m[0;34m[0m[0m

[0;31mImportError[0m: numpy.core.multiarray failed to import
ImportError: numpy.core.multiarray failed to import

